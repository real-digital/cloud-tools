[
{
	"uri": "/pligos/public/pligos-components/schema/",
	"title": "Schema Compiler",
	"tags": [],
	"description": "",
	"content": " Pligos heavily relies on yaml configurations. In order to compile one set of configurations into different contexts (for example CI,dev,prod) pligos comes with it\u0026rsquo;s own simple schema language to describe the context. The idea is to create a single helm starter that supports a big set of your services. Services then differ only in their templating input (given in pligos.yaml file).\nPligos supports the following basic types: string, numeric, bool, object. Example:\n# schema.yaml context: pullPolicy: string useTLS: bool applicationConfig: object podInstances: numeric  contexts, flavor and spec are reserved words in following pligos.yaml. You need to provide your schema configuration under spec.\n# example/pligos.yaml -- this is your actual service configuration, define this for all your services individually contexts: dev: # Path to flavor folder that contains schema.yaml and templates folder flavor: ./flavor spec: pullPolicy: Always useTLS: true applicationConfig: fixture: user: \u0026quot;John Doe\u0026quot; balance: \u0026quot;10$\u0026quot; podInstances: 1  # example/values.yaml -- this file will be generated by pligos pullPolicy: \u0026quot;Always\u0026quot; useTLS: true applicationConfig: fixture: user: \u0026quot;John Doe\u0026quot; balance: \u0026quot;10$\u0026quot; podInstances: 1  As mentioned above pligos allows defining different contexts (dev, prod, \u0026hellip;). Each context needs to be set under the contexts property in the service configuration.\n# schema.yaml -- the schema definition for the dev context context: environment: string srcPath: string  # example/pligos.yaml contexts: dev: flavor: ./flavor spec: environment: dev srcPath: /home/johndoe/dev/src/ prod: flavor: ./flavor spec: environment: prod srcPath: /home/johndoe/prod/src/  Then running the pligos for prod will generate the following values.yaml\n# example/values.yaml -- this file will be generated by pligos environment: prod srcPath: /home/johndoe/prod/src/  However the true power of pligos comes through custom types, which can be instantiated and composed in the configuration.\n# schema.yaml route: port: string container: route: route context: container: container  # example/pligos.yaml contexts: dev: flavor: ./flavor spec: container: gowebservice values: route: - name: http port: 80 container: - name: gowebservice route: http  # helmcharts/example/values.yaml container: route: port: 80  Notice that in the configuration, the instances are referenced by their name. name is a special property in pligos which is used for referencering configuration instances (such as the gowebservice container) and mapped types. More to mapped types later.\nAdditionally the language supports the meta types repeated, mapped, embedded and embedded mapped which can be applied to any custom, or basic types. Let\u0026rsquo;s start with an example for repeated instances.\nUse of repeated instance # schema.yaml container: name: string command: repeated string context: container: repeated container  # example/pligos.yaml contexts: dev: flavor: ./flavor spec: container: [\u0026quot;nginx\u0026quot;, \u0026quot;php\u0026quot;] values: container: - name: nginx command: [\u0026quot;nginx\u0026quot;] - name: php command: [\u0026quot;php-fpm\u0026quot;]  # examples/values.yaml container: - name: nginx command: - nginx - name: php command: - php-fpm  Repeated allows specifying a list of any type. In the example we have a list of container, as well as a property command which is a list of string.\nUse of mapped instance Next, Pligos also allows you to define maps.\n# schema.yaml route: name: string port: string containerPort: string context: routes: mapped route  # example/pligos.yaml contexts: dev: flavor: ./flavor spec: routes: [\u0026quot;http\u0026quot;] values: route: - name: http port: 80 containerPort: 8080  # example/values.yaml routes: http: port: 80 containerPort: 8080  Notice that, although the configuration defines an array of routes, pligos yields a map, as shown in the the output. Maps can be created using the mapped meta type.\nUse of embedded instance Up until this point all custom types appeared under some key in the output. However, this is not always the desired behavior. In order to embed the types\u0026rsquo; properties into the parent embedded types can be used.\n# schema.yaml rawValues: values: embedded object context: rawValues: embedded rawValues  # example/pligos.yaml contexts: dev: flavor: ./flavor spec: rawValues: devenvironment values: rawValues: - name: devenvironment values: mysql: user: testuser password: asdf  # example/values.yaml mysql: user: testuser password: asdf  Use of embedded mapped instance Similarly the instance can be embedded using any arbitrary key using embedded mapped types.\n# schema.yaml dependency: port: string hostname: string context: dependencies: embedded mapped dependency  # example/pligos.yaml contexts: dev: flavor: ./flavor spec: dependencies: [\u0026quot;mysql\u0026quot;] values: dependency: - name: mysql port: 3306 hostname: mysql  # example/values.yaml mysql: port: 3306 hostname: mysql  Just as with mapped types, the name property is used to embedd the type instance into the parent.\n"
},
{
	"uri": "/pligos/public/",
	"title": "Pligos Documentation",
	"tags": [],
	"description": "This article describes how we can use pligos to manage helm charts easily.",
	"content": " Pligos Documentation Overview Pligos allows you to navigate multiple services by making kubernetes infrastructure configuration scalable. Without pligos, the usual approach is to create a seperate helm chart for each service. While this definitely can scale for a small amount of services, maintaining deployment, service, ingress, ... templates for more than 5 helm charts can be burdensome and error prone.\nWe observed that services, in it\u0026rsquo;s core, often don\u0026rsquo;t differ that much. You can find a set of configurations that need to be individually defined for each service, such as images, routes, mounts, ..., so why not standardize around these configuration types, while beeing disconnected from the underlying templates? This is why pligos let\u0026rsquo;s you define these configuration types (image, route, ...) and adds a schema language that allows you to compile those configs into any form necessary.\nSo, what you will end up with is a small set of helm starters (in pligos lingua franca they are called flavors) and a pligos configuration for each service that map to these flavors.\nPligos helps you to manage your deployment in multiple environments by specifying your configurations in a single file called pligos.yaml. By using pligos, you don\u0026rsquo;t need to play with the files within templates folder. Neither you have to dig into the multiple values.yaml files. You\u0026rsquo;ll design a generic templates folder (called as pligos flavor) in a way to meet most of your requirements for your multiple micro-services.\nThen for deploying a new micro-service, all you have to do is specify your values for local, staging, production or whatever, in pligos.yaml and you are good to go.\nIt makes much easier for you to manage cloud infrastructure. For example, if you want to update the hostname for your ingress in future, you don\u0026rsquo;t have to find and replace it from bunch of files. You just need to modify your pligos.yaml accordingly.\n"
},
{
	"uri": "/pligos/public/motivation/",
	"title": "Motivation",
	"tags": [],
	"description": "",
	"content": " Opinions Behind Pligos The following article is going to describe the opinions on why Pligos is the superior Kubernetes manifest management tool and why Pligos is not even trying to be a manifest management tool. Managing Kubernetes manifests is hard and has many flaws, Joe Beda one of the original authors agrees and probably the whole community.\nAs @bryanl says: YAML is for computers. When we started with YAML we never intended it to be the user facing solution. We saw it as \u0026quot;assembly code\u0026quot;. I\u0026#39;m horrified that we are still interacting with it directly. That is a failure.\n\u0026mdash; Joe Beda (@jbeda) 10 May 2018   That\u0026rsquo;s why an abundance of tools have been published to mitigate this problem. However there are tools, such as draft.sh that are fairly close but there is no solution which fixes this issue in it\u0026rsquo;s entireness. So let us explain:\nIn our opinion, with tools such as helm, ksonnet and kapitan we are inventing a lot of clever ways to make Kubernetes manifest templating bearable. While we agree, that some of the solutions (such as using jsonnet over Go templating) are more effective than others we are not addressing the real issue. Kubernetes manifests are a way to describe Kubernetes resources. While we are forced to describe Kubernetes resources, what we really want to do is describe configuration for our services. And because of that we are doing the same task over and over again, which is mapping everything our service requires to what the Kubernetes API offers. We often invent clever little strategies to do just that and often times, while defining the configuration for one service, we realize how everything could have been done so much better for the last few services. As a result of this we either let our configuration style diverge, or we take the time and refactor. Neither options are optimal and above all unnecessary.\nThe only way out of this mess is to disconnect infrastructure configuration from Kubernetes manifest management. What is meant by that? When we\u0026rsquo;re talking about infrastructure configuration we usually have something like this in our mind:\nroute: - name: http applicationPort: 8080 exposeAs: 80 protocol: TCP path: /myservice/api/v1  This configuration describes exactly how we want our service to behave once it\u0026rsquo;s deployed inside a Kubernetes environment. We are stating that we have some service, which is going to listen on port 8080, while we want it to be exposed on port 80. Also, we want it to be accessible on the path https://my.cluster/myservice/api/v1. This configuration is universally true, regardless of how we map it to the Kubernetes API. In order to close the gap between what we defined in this little example and how our kubernetes manifests are defined we could use any of the tools already out there, the leading examples being Helm or ksonnet. The important part is, that you create as few Helm, ksonnet, whatever configuration instances as possible, such that you don\u0026rsquo;t repeat yourself and can keep the refactoring to a minimum. Generally, you could even stick to three configuration instances: stateless web services, stateful applications and per node daemons.\nPligos is currently implemented to use helm. It is based on a concept called flavors, which are basically helm starters with a public API, called schema which describes the structure in which your application should be configured. One example of such a configuration is shown above already. This allows the mapping of multiple services to a single helm chart. Once you configured your service based on the schema definition Pligos goes on and compiles the input configuration into something that maps to the configuration template. Additionally, Pligos also treats the management of different contexts (development, production, ci) as a first class citizen. In conjunction with this, it\u0026rsquo;s also planned to support secret management (TLS certificates, docker registry secrets, \u0026#x2026; ) and application configuration management. Pligos already is designed with application configuration management in mind, however this is a whole topic on it\u0026rsquo;s own.\nWhen Joe Beda is talking about \u0026ldquo;the horrible state we are in regarding Kubernetes yaml configurations\u0026rdquo;, people put too much focus on yaml being the issue. Yes, yaml might not be the final answer, however, we need to fight different issues. Pligos is here to minimize the handling of Kubernetes manifests and instead tries to provide a configuration interface that let\u0026rsquo;s us define behavior of our configuration in the cloud, not Kubernetes manifests.\nHow Pligos minimizes the effort to manage Helm Charts? Let\u0026rsquo;s suppose that you have 10 micro-services and each micro-service has it\u0026rsquo;s own deployment.yaml, service.yaml, ingress.yaml etc. So, you can easily assume that how hectic it is to manage such huge number of files. Also, it raises lot of chances for mistakes too.\nBut on the other hand, by using pligos, you will have a single set of deployment.yaml, service.yaml, ingress.yaml etc. All the micro-services will be using this common set. And each micro-service will only have its own pligos.yaml to define its configurations. It makes much more easier to manage this setup, no matter how many micro-services you need to deploy.\n"
},
{
	"uri": "/pligos/public/pligos-components/types/",
	"title": "Types",
	"tags": [],
	"description": "",
	"content": " You define your custom definition for your objects that you want to use within pligos.yaml. For example, you know that when we want to setup service for kubernetes, we need to know the service type and port. So, the service can be defined as:\nservice: type: string port: numeric  Another example could be for Image that is used within deployment. So, you know that image has following attributes:\n registry repository tag pullPolicy  So, it can be defined in types.yaml as :\nimage: registry: string repository: string tag: string pullPolicy: string  Supported Types Pligos supports the following basic types:\n string numeric bool object  Want to see types.yaml in action? Have a look on our getting-started guide\nAdditionally the language supports the following meta types which can be applied to any custom, or basic types:\n repeated mapped embedded embedded mapped  These types are explained with example in schema compiler\nWhere these types can be defined? You can define your context structure and your types both in schema.yaml just like the examples given at schema compiler . Another short example could be as following:\n#schema.yaml route: port: string container: route: route context: container: container  # pligos.yaml pligos: version: '1' # As we don't have separate types file in this case, so we can leave this empty types: [] contexts: dev: # This flavor folder contains schema.yaml and templates flavor: ./flavor spec: container: gowebservice values: route: - name: http port: 80 container: - name: gowebservice route: http  But if you want to separate the generic types and context structure of your specific flavor (in this way, you can reuse your types across different flavors), then you can have separate types.yaml and schema.yaml\n# types.yaml route: port: string container: route: route  # schema.yaml context: container: container  # pligos.yaml pligos: version: '1' # Path to types.yaml types: [./types.yaml] contexts: dev: # This flavor folder contains schema.yaml and templates flavor: ./flavor spec: container: gowebservice values: route: - name: http port: 80 container: - name: gowebservice route: http  "
},
{
	"uri": "/pligos/public/basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": " Installation Pligos installation is super easy. If you have already installed the helm (to install helm follow the instructions here ), then you can simply install pligos as helm plugin by following commands:\nFor OSX\nhelm plugin install https://github.com/real-digital/pligos/releases/latest/download/darwin_amd64_pligos.tar.gz  For Linux\nhelm plugin install https://github.com/real-digital/pligos/releases/latest/download/linux_amd64_pligos.tar.gz  Command Pligos can be used by following command:\n#It will render the pligos.yaml and generate the values.yaml #containing the configuration for \u0026lt;context-name\u0026gt; context #And it will also create templates folder with required #files (from flavor) automatically helm pligos \u0026lt;context-name\u0026gt; -c \u0026lt;path-to-pligos.yaml\u0026gt; #Example: Running pligos for local context helm pligos local -c /my-deployment  If you need some more help for using pligos, you can use the following command to get help about pligos.\nhelm pligos --help  "
},
{
	"uri": "/pligos/public/pligos-components/file-structure/",
	"title": "File Structure",
	"tags": [],
	"description": "",
	"content": "Pligos.yaml consists of 3 parts.\n pligos contexts values  And these are described in the following image: Sample pligos.yaml file can be found here\n"
},
{
	"uri": "/pligos/public/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Introduction Ahoi!\nLet me try to introduce you to Pligos again. Please be aware that this /getting started/ might seem a little bit fabricated .That\u0026rsquo;s because it is. Pligos is meant to support huge environments and it is hard to show off Pligos\u0026rsquo; features on such a simple example. Anyway here goes nothing!\nThis introduction assumes that you have already familiarized yourself with helm and what it does. Pligos is a helm plugin and deeply nested with helm, so it might be helpful to have some knowledge of helm. If you didn\u0026rsquo;t, try reading and understanding helm.sh/using_helm.\nMy take on helm: it\u0026rsquo;s a glorified templating tool that somehow managed to check all the right boxes and is therefore extremely useful as a kubernetes configuration management tool. On the other hand it\u0026rsquo;s shitty for scaling and development, but that\u0026rsquo;s what you are here for (hopefully).\nFlavor or the helm starter with super powers Pligos relies on something called a Flavor. You can think of a Flavor as a helm starter with super powers. It provides a schema so that you actually know what is going on inside of it and isn\u0026rsquo;t actually used as a starter for your chart, but as a library of template files. As is common with libraries you can share Flavors with all your fellow computer nerds without exposing them to your service configurations. Also you can collaborate on improving the Flavor/library such that everyone benefits from updates!\nA sample flavor named webservice is given as following (it is just an example, your flavor could be different) :\nSo how is a Flavor similar to a helm starter? well it\u0026rsquo;s still a helm chart, so let\u0026rsquo;s actually create one using helm. This flavor is going to be used by stateless web services. We are going to call it webservice!\n helm create webservice  Now, despite this being a chart we will never inject any values into it (the reason is that this flavor is just considered to be a template and all of our helm charts will be using this template and generating their own values.yaml file), so let\u0026rsquo;s remove the values.yaml. Tests is also something that belongs to your specific chart, so get rid of those as well.\n rm webservice/values.yaml rm -r webservice/templates/tests  However we do need a schema.yaml that defines the schema of the chart. So, let\u0026rsquo;s create the schema.yaml file inside the webservice folder by following command:\n echo \u0026quot;context: {values: embedded configuration}\u0026quot; \u0026gt; webservice/schema.yaml  And already you got yourself a valid flavor. It\u0026rsquo;s not very useful, but we will come to that later.\nTypes You might be wondering what the actual hack we just wrote to this innocent little schema file. Well at this point even Pligos would wonder what it is, because we need to feed you and Pligos more information about it! Pligos is operating based on custom configuration types. In the example we made use of a type called configuration and are going to define it now.\nThe important part here is, that types are something that YOU define. I would love to do that for you, but than I would just force on you a shittier version of the kubernetes API because I can not understand your requirements. That is what Pligos is all about, configuring your services in alignment of your organization\u0026rsquo;s requirements. However I can make some broad guesses in order to further kick the tires on this /getting started/. To learn more about how to define types and Pligos\u0026rsquo; DSL go to schema compiler.\nAlright, let\u0026rsquo;s define our configuration type in the file named types.yaml. You can create this file anywhere and use its path accordingly in the further steps. I\u0026rsquo;ve created it outside of the webservice folder.\n echo \u0026quot;configuration: { valuesyaml: embedded object }\u0026quot; \u0026gt; types.yaml  I am again making use of the Pligos keyword /embedded/ here. Please go to the DSL documentation (schema compiler) if you want to learn what it does.\nAlright, so we defined our configuration type! Congratulations, not that hard, right? It seems that a configuration instance needs to define a single key, called valuesyaml that needs to be an object. I think we can do that! Let\u0026rsquo;s actually start benefiting from our efforts and create our first Pligos configuration.\nHello-world pligos configuration As a helm plugin, every Pligos configuration naturally is also a helm chart. We\u0026rsquo;ll create our own helm chart and it will be using the webservice as the template. I think we have already mastered creating helm charts so this one should be easy:\n helm create hello-world  Templates will be provided by our Flavor, so let\u0026rsquo;s kill them with fire!\n rm -r hello-world/templates  In order to morph this beautiful helm chart to a Pligos capable one, I propose to replace the values.yaml with something more useful. Let\u0026rsquo;s remove the values.yaml file and create the pligos.yaml file inside the hello-world:\n rm hello-world/values.yaml touch hello-world/pligos.yaml  values.yaml and our beloved templates will come back soon, but, as they are generated, we don\u0026rsquo;t actually need to commit them anymore, so I think it\u0026rsquo;s good practice to ignore them:\n printf \u0026quot;/values.yaml\\n/templates\\n\u0026quot; \u0026gt; hello-world/.gitignore  Let\u0026rsquo;s start editing the pligos.yaml. At first we are going to add a header to the file that defines some metadata which, most importantly links to the types we just created:\n # hello-world/pligos.yaml pligos: version: '1' types: [../types.yaml]  Have you noticed why I have given the path of types.yaml as \u0026ldquo;../types.yaml\u0026rdquo; ?. This is because my types.yaml is outside of this helm chart folder. But you can give the path of types.yaml according to the location where you have created it in previous step.\nYou might notice, that we can actually plug multiple type definition files into your Pligos configuration. Multiple files are simply going to be merged.\nWe are actually getting really close to something that can be deployed, so bare with me, we can do this! The only thing left is creating a /Context/.\nContexts Contexts allow you to manage different versions of your service configurations. The most obvious use case is to have a development and production version. Doing this without Pligos normally requires managing multiple values.yaml files, each one overwriting a base values.yaml file. Using Pligos this nonsense can finally come to an end because you can manage all the versions side by side inside of one file. You will see how this scales (spoiler: this is what type instances are for).\nTo ease into the concept let\u0026rsquo;s create a single first context called default in our pligos.yaml which holds the configuration for a default helm chart. Go ahead and copy this first context below the metadata header we just defined:\n # hello-world/pligos.yaml contexts: default: flavor: ../webservice spec: values: valuesyaml: image: repository: nginx tag: stable pullPolicy: IfNotPresent service: type: ClusterIP port: 80 ingress: {enabled: false}  Looks complicated? Thats ok, because that\u0026rsquo;s not how you would normally use Pligos. I only show you this to make clear how simple it is to create a configuration instance. As you can see we can now use a single context default that uses the webservice flavor we created and references a configuration instance using the values key. Why it uses the values key you ask? Well le\u0026rsquo;ts have a look again at our schema definition:\n # webservice/schema.yaml context: values: embedded configuration  As you can see, the schema we created for the webservice Flavor requires us to create a configuration instance under the values key, it\u0026rsquo;s as simple as that! And if we think back we can remember, that the valuesyaml key is part of the configuration type.\nFinally done with that, you can now run pligos for the first time and will see the values.yaml file as well as the templates reappear!\n helm pligos default -c hello-world cat hello-world/values.yaml  I told you that normally you don\u0026rsquo;t create configurations like that. Let\u0026rsquo;s try doing it the Pligos idiomatic way! I suggest that we create a /named instance/ of the configuration type. Named instances are defined under the values key which you define at the root of the pligos.yaml. Go ahead and copy the following below the context definition.\n # hello-world/pligos.yaml values: configuration: - name: default valuesyaml: image: repository: nginx tag: stable pullPolicy: IfNotPresent service: type: ClusterIP port: 80 ingress: {enabled: false}  Now change your context definition to the following:\n # hello-world/pligos.yaml contexts: default: flavor: ../webservice spec: values: default  So, your pligos.yaml till this step will look like as following:\n # hello-world/pligos.yaml pligos: version: '1' types: [../types.yaml] contexts: default: flavor: ../webservice spec: values: default values: configuration: - name: default valuesyaml: image: repository: nginx tag: stable pullPolicy: IfNotPresent service: type: ClusterIP port: 80 ingress: {enabled: false}  As you can see, instead of defining configuration instances inline, you can created named instances and reference them elsewhere. This actually introduces us to the concept of composition within Pligos. Go run\n helm pligos default -c hello-world cat hello-world/values.yaml  again to make sure nothing on the output changed. BTW you can go ahead and deploy this configuration using your familiar helm commands:\n helm upgrade --install hello-world ./hello-world  This should yield the same results as deploying a default helm chart without any modifications.\nComposition You made it this far, I am proud of you! We can now finally dive into probably the most important feature of Pligos: composition.\nMaybe you are like me and use different ingress configurations for development and production. For instance, I use a different hostname and no tls during development. We could extend our current configuration like this to support both environments:\n # hello-world/pligos.yaml contexts: development: flavor: ../webservice spec: values: development default: flavor: ../webservice spec: values: default values: configuration: - name: development valuesyaml: image: repository: nginx tag: stable pullPolicy: IfNotPresent service: type: ClusterIP port: 80 ingress: enabled: true hosts: [{host: pligos-dev.sh , paths: [ / ]}] - name: default valuesyaml: image: repository: nginx tag: stable pullPolicy: IfNotPresent service: type: ClusterIP port: 80 ingress: enabled: true hosts: [{host: pligos.sh , paths: [ / ]}] tls: - secretName: pligos-tls hosts: [pligos.sh]  This does work, however we duplicated a lot of the configuration! Wouldn\u0026rsquo;t it be far better to use composition to configure once and stick it all together like little legos?\nIn order to do this I propose we add an ingress type. Modify your types.yaml to look like this:\n # types.yaml configuration: valuesyaml: embedded object tls: secretName: string hosts: repeated string ingress: enabled: bool hosts: repeated object tls: repeated tls  As you can see I took the liberty of creating a third type tls which is not directly used by our context definition, but by the ingress type. This shows that composition with Pligos works at any level and can be used arbitrarily.\nLet\u0026rsquo;s extend our schema.yaml inside of our Flavor to make use of the type:\n # webservice/schema.yaml context: values: embedded configuration ingress: ingress  Now let\u0026rsquo;s fix our pligos.yaml and free our configuration from all the nasty repetition. The end result should look like this:\n # hello-world/pligos.yaml pligos: version: '1' types: [../types.yaml] contexts: development: flavor: ../webservice spec: values: default ingress: development default: flavor: ../webservice spec: values: default ingress: production values: tls: - name: production secretName: pligos-tls hosts: [pligos.sh] ingress: - name: production enabled: true hosts: [{host: pligos.sh , paths: [ / ]}] tls: [production] - name: development enabled: true hosts: [{host: pligos-dev.sh , paths: [ / ]}] configuration: - name: default valuesyaml: image: repository: nginx tag: stable pullPolicy: IfNotPresent service: type: ClusterIP port: 80  As you can see our configuration looks much cleaner and it is immediately obvious where to find what configuration piece and what it is used for. We were able to remove the second configuration instance as the ingress was the only distinguishable factor. Going further with this configuration style I can assure you that different environments can be defined much more easily and scalable.\nSo, Congratulations you are done with it. Now, you can again just test to check if everything is working fine by using the Flavor.\n helm pligos default -c hello-world helm upgrade --install hello-world ./hello-world  "
},
{
	"uri": "/pligos/public/pligos-components/",
	"title": "Pligos Components",
	"tags": [],
	"description": "",
	"content": "  Schema Compiler   Types   File Structure   "
},
{
	"uri": "/pligos/public/example/",
	"title": "Example",
	"tags": [],
	"description": "",
	"content": " Example Using Pligos You can find a basic example of pligos at this repo\nClone the repo\ngit clone https://github.com/real-digital/pligos.git  Get into the example directory\ncd pligos/examples/pligos/configs/golang-hello-world  The structure of this directory is as following: Note: You can see that this directory is missing the values.yaml file and templates folder. Because these two will be created by pligos.\nSo, Run the pligos command.\n#helm pligos \u0026lt;context-name\u0026gt; -c \u0026lt;path-to-pligos.yaml\u0026gt; helm pligos default -c .  Note: Please keep in mind that we\u0026rsquo;re using here default because our pligos.yaml contains the context named default.\nNow, you\u0026rsquo;ll see that there is auto-generated values.yaml file and templates folder. Then you can run your usual helm command to deploy this hello-world example.\nhelm upgrade --install hello-world .  "
},
{
	"uri": "/pligos/public/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/pligos/public/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]